#### 次方求模
```
long long PowerMod(long long a, long long  b, long long c)
{
    long long ans = 1;
    a = a % c;
    while(b>0)
    {     
    if(b % 2 == 1)
    ans = (ans * a) % c;
    b = b/2;
    a = (a * a) % c; 
    }
    return ans;
}
```
### 素数
#### 筛法求素数
```
const int N = 200000;
int prime[N] = {0},num_prime = 0;
//prime[n] store prime number ;num_prime is the number of prime;
int isNotPrime[N] = {1, 1};
	for(int i = 2 ; i < N ; i ++)
       	{
		if(! isNotPrime[i])
	 		prime[num_prime ++]=i;
		for(int j = 0 ; j < num_prime && i * prime[j] <  N ; j ++)
    		{
		      	isNotPrime[i * prime[j]] = 1;
	  		if( !(i % prime[j] ) ) 
				break;
            }
        }
```
#####  问题
单色三角形。给定n个点，没有3点共线。每两个点之间都用红或黑连接。求3条边同色的三角形个数。
对于非单色三角形数量：第i个点a[i]个红边 非单色三角形数量 
```math
1/2 \sum_i ai(n-1-ai)
```
#### polya定理
等价计数问题中一个有m种置换，n种颜色进行作色，每种置换的循环个数为a[i]，则一共的着色方案：
```math
1/m  \sum_i^m  n^a[i]
```
针对多边形着色，只考虑旋转：每次跨度为i(1-n)
则形成置换的循环个数为gcd(i,n);
再考虑对称折叠

有n个对称轴分n为奇数还是偶数讨论。

#### 高斯消元
处理第i行，寻找r>i 且绝对值最大的一行r交换第i行和第r行，在A可逆时，保证交换后aii一定不等于0
``` 
//要求系数矩阵可逆
//A增广,A[i][n]表示b[i]
//运行结束后A[i][n]是第i个未知数解
const int maxn=1005;
typedef double Matrix[maxn][maxn];
void gauss_elimination(Matrix &A,int n){
    int i,j,k,r;
    //消元
    for( i=0;i<n;i++)
    {
        r=i;
        for(j=r+1;j<n;j++)
            if(abs(A[j][i])>abs(A[r][i]))
                r=j;
        if(r!=i)
            for( j=0;j<=n;j++)
            swap(A[i][j],A[r][j]);
        //与i+1~n进行消元
        for(k=i+1;k<n;k++)
        {
            double f=A[k][i]/A[i][i];
            for(j=i;j<=n;j++)
                A[k][j]-=f*A[i][j];
        }
    }
    //回代求解未知数
    for(i=n-1;i>=0;i--)
    {
        for(j=i+1;j<n;j++)
        {
            A[i][n]-=A[j][n]*A[i][j];
        }
        A[i][n]/=A[i][i];
    }
}
```
 **关于精度问题**
从大到小逆序消元可以减少精度差。(很少用)
#### 矩阵快速幂
```
const int MAXN=1010;
const int MAXM=1010;
struct Matrix{
int n,m;
int a[MAXN][MAXM];
void m_clear()
{
    n=0;m=0;
    memset(a,0,sizeof a);
}
Matrix operator + (const Matrix &b) const {
    Matrix tmp;
    tmp.m_clear();
    tmp.n=n;tmp.m=m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
                tmp.a[i][j]=a[i][j]+b.a[i][j];
    return tmp;
}
Matrix operator - (const Matrix &b) const {
    Matrix tmp;
    tmp.m_clear();
    tmp.n=n;tmp.m=m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
                tmp.a[i][j]=a[i][j]-b.a[i][j];
    return tmp;
}
Matrix operator * (const Matrix &b) const {
    Matrix tmp;
    tmp.m_clear();
    tmp.n=n;tmp.m=b.m;
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            for(int k=0;k<m;k++)
                tmp.a[i][j]+=a[i][k]*b.a[k][j];
    return tmp;
}
void m_print()
{
    for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
                cout<<a[i][j]<<' ';
            cout<<endl;
        }
}
};
Matrix m_pow(Matrix A,int n)  n=m<=23 时可以使用，可能收到内存不连续的限制无法赋值=
{
    Matrix tmp;
    tmp.m_clear();
    tmp.n=A.n;tmp.m=A.n;
    for(int i=0;i<A.n;i++)
        tmp.a[i][i]=1;
    while(n>0)
    {
        if(n&1)
            tmp=tmp*A;
        A=A*A;
        n>>=1;
    }
    return tmp;
}
```
#### 矩阵性质

1  | 1 | 0 |...|0  |1
---|---|---|---|---|---
0 | 1| 1| 0| 0|...     |0
0|0|1 | 1| 0|0|...|     0

这样的矩阵，每一行等于上一行右移一位，称为循环矩阵。

**循环矩阵**相乘仍然是循环矩阵。所以只用算出第一行即可。减少复杂度到 N*N

循环矩阵只需要记录第一行a[0][i],a[i][j]=a[(j-i+n)%n]
```
int mmd;
const int MAXN=520;
struct Matrix{//循环矩阵
int n;
ll a[MAXN];
void m_clear()
{
    n=0;
    memset(a,0,sizeof a);
}
Matrix operator * (const Matrix &b) const {
    Matrix tmp;
    tmp.m_clear();
    tmp.n=n;
    for(int i=0;i<n;i++)
        {
            for(int j=0;j<n;j++)
                tmp.a[i]=(tmp.a[i]+a[j]*b.a[(j-i+n)%n]%mmd)%mmd;
        }
    return tmp;
}
}matrix;
Matrix m_pow(Matrix& A,int n)
{
    Matrix tmp;
    tmp.m_clear();
    tmp.n=A.n;
    tmp.a[0]=1;
    while(n>0)
    {
        if(n&1)
            tmp=tmp*A;
        A=A*A;
        n>>=1;
    }
    return tmp;
}
```
### 数值方法
