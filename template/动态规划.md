### 最大子段和
```
int maxlen=-1e8;
for(int i=1;i<n;i++)
{
    dp[i]=max(dp[i-1]+minuss[i],minuss[i]);
     maxlen=max(maxlen,dp[i]);
}
```
### LIS最长上升子序列
####    O n*logn

d[i]存长度为i的上升子序列的最小末元素    可以推出d[i]中的元素师按从小到大排列的

若d[i-1]比d[i]大，则上述中的长度为i-1的序列的末元素可以更新它
若当前元素最大，则长度增加
否则找到一个他可以更新的，更新之

**题意**：针脚之间有一些连线，有的交叉，现在不允许交叉，求最多能留下几根线
以某一边为序，求一个最长上升子序列的长度即可
```
    d[1]=a[1];
    int len=1,l,r,mid;
    for(int i=2;i<=n;i++)
    {
        if(d[len]<a[i])
            {
                d[++len]=a[i];
                continue;
            }
            l=1,r=len;
            while (l<=r)
            {
                mid=(l+(r-l)/2);
                if(d[mid]<a[i])
                    l=mid+1;
                else     r=mid-1;
            } 
            d[l]=a[i];
    }
    printf("%d\n",len);
```
### 最大递增子段和
dp[i]=max(dp[j])+a[i];

dp[i]表示以i为结尾的最大子段和,满足 1<=j<i
### 最小回文代价
对每个字母insert[i],delete[i],求回文最小代价。




DAG图求最长路径
先拓扑排序，然后dp

### 最优矩阵链乘 (区间dp)
```
    for(int i=1;i<=n;i++)//第i个matrix的行列为a[i],a[i+1]
    {
        cin>>a[i];
    }
    for(int i=1;i<n;i++)
        for(int j=i+1;j<=n;j++)
        {
            dp[i][j]=1e9;
        }
    for(int len=2;len<=n-1;len++)//length
    {
        for(int i=1;i+len-1<n;i++)//start
        {
            for(int k=i;k<i+len-1;k++)
            {
                dp[i][i+len-1]=min(dp[i][k]+dp[k+1][i+len-1]+a[i]*a[k+1]*a[i+len],dp[i][i+len-1]);
            }
        }
    }

```

#### 区间dp减少时间复杂度
dp[i]表示以i结束的区间的最优值

接着for()一遍找到dp[i]中的最优值 可以将3维变2维for循环
### 三角剖分
注意如果中间三角形i-k-j中有其他的点,这样的三角形是不可以剖分的

三角形面积注意精度

fabs((x[k] - x[i]) * (y[j] - y[i]) - (x[j] - x[i]) * (y[k] - y[i])) / 2.0 ;

## 树上dp
树上动态规划常由儿子推老子，但写法上可以由老子找儿子常递归写法
### 树的最大独立集
```
//uva 1220
int n;
vector<int>son[201];
int f[210][2];
//dp[u][0]表示以u为root,不选u最多节点数 f[u][0]==1表示 解唯一
//dp[u][1] root u contain u的节点数  f[u][1]==1 表示 含u解唯一
int dp(int root,int have)
{
    if(son[root].size()==0)
    {
        f[root][have]=1;
        if(have==1)
            return 1;
        else return 0;
    }
    if(have==1)
    {
        int sum=0;
        f[root][1]=1;
        for(int i=0;i<son[root].size();i++)
            {
                sum+=dp(son[root][i],0);
                if(f[son[root][i]][0]==0)
                    f[root][1]=0;
            }
        return sum+1;
    }
    if(have==0)
    {
        int sum=0;
        f[root][0]=1;
        for(int i=0;i<son[root].size();i++)
            {
                int t0=dp(son[root][i],0);
                int t1=dp(son[root][i],1);
                sum+=max(t0,t1);
                if(t1==t0)
                    f[root][0]=0;
                if(t1<t0)
                {
                    if(f[son[root][i]][0]==0)
                        f[root][0]=0;
                }else{
                    if(f[son[root][i]][1]==0)
                        f[root][0]=0;
                }
            }
        return sum;
    }
}
```
### 树的重心

树的重心为 去掉此点后，树形成子树各个最多节点数最小
d(u) 表示以u为根的树含节点数
重心为 节点c 删除c后 最多节点数为max(d(son of c),n-d(c));
直接dfs一遍

### 树的最长路径（直径）
每个点求到叶子节点最大距离。则对经过每个点的最大路径即为i的子树中，距离最大的2点。

2个性质：

性质一：在树上任取一点u，设距u最远的一点为s，距s最远的一点为t，则s到t的路径即为树的直径

性质二：树的直径的长度一定会是某个点的最长距离f[i]与次长距离g[i]之和


## 状压DP
状态压缩DP的特点：

状态中的某一维会比较小，一般不会超过15，多了的话状态数会急剧上升而无法压缩，一般来说需要状态压缩的也就是这一维。

当需要表示一个集合有哪些元素时，往往利用2进制用一个整数表示。

一道例题：HOJ 2662

有一个n *m的棋盘(n、m≤80,n *m≤80)要在棋盘上放k(k≤20)个棋子，使得任意两个棋子不相邻（每个棋子最多和周围4个棋子相邻）。求合法的方案总数。
    
直接考虑解决这个问题并不容易，我们先来考虑这个问题的退化形式：现在我们令n=1。则我们可以很容易的想到状态转移方程：

设dp[i][j][0]表示当前到达第i列，一共使用了j个棋子，且当前格子的状态为不放的状态总数，类似的 dp[i][j][1]就是当前格子的状态为放的状态总数。那么状态转移方程就是

dp[i][j][0]=dp[i-1][j][1]+dp[i-1][j][0];
dp[i][j][1]=dp[i-1][j-1][0];

当n=1的时候这个问题无疑是非常简单的，但是如果我们想模仿这种做法来解决原问题的话，就会遇到这样的问题：如何来表示当前行的状态？

对于每一行，如果把没有棋子的地方记为0，有棋子的地方记为1，那么每一行的状态都可以表示成一个2进制数，进而将其转化成10进制。

那么这个问题的状态转移方程就变成了
设dp[i][j][k]表示当前到达第i行，一共使用了j个棋子，且当前行的状态在压缩之后的十进制数为k 时的状态总数。那么我们也可以类似的写出状态转移方程：

dp[ i ][ j ][ k ]=sum( dp[ i-1][ j-num(k) ][ w ] )   num(k)表示 k状态中棋子的个数，w表示前一行的状态。

判断每一行状态是否合法，可以在程序一开始判断然后保存结果，判断k状态和w状态上下之间是否有相邻的棋子，可以利用位运算，if(k&w)说明上下之间有相邻的棋子等等。



## 数位DP
数位dp的特点是 给一个n 问1-n 有多少个数满足性质x
　所谓数位DP就是基于考虑数字的每一位来转移的DP。

　　　　例如求比456小的数，可以这么考虑，
```
4          5             6

4　        5            (0~6)

4         (0~4)         (0~9)
(0~3)     (0~9)         (0~9)
　　　

一般 问法：L-R 中不含  49 （或者62）的数有多少个
转化为0-R 和0-L 的差
dp[i][j] 表示长度为i的数（也就是有i位数）状态为j的数的总数有多少
本题状态有三种： 
dp[i][0]代表长度为i且不包含49的数有多少个
dp[i][1]代表长度为i且不包含49且左边第一位（最高位）为9的数有多少个
dp[i][2]代表长度为i且包含49的数有多少个
打表预处理，0<=i<=21（21位就够了）,主要是处理状态的转移
dp[i][0]=dp[i-1][0]*10-dp[i-1][1];//dp[i][0]高位随便加一个数字都可以，但是会出现49XXX的情况，要减去
dp[i][1]=dp[i-1][0];             //在不含49的情况下高位加9
dp[i][2]=dp[i-1][2]*10+dp[i-1][1]; //在含有49的情况下高位随便加一位或者不含49但高位是9，在前面最高位加上4就可以了

long long dp[22][3];
int bit[22];//注意bit为倒序排列n eg：n=1234;bit=4321;
void init()
{
    dp[0][0]=1;//长度为0赋值为1 为了使长度为1时dp[1][0]=10;dp[1][1]=1;dp[1][2]=0;
    dp[0][1]=0;dp[0][2]=0;
    for(int i=1;i<=21;i++)
    {
        dp[i][0]=dp[i-1][0]*10-dp[i-1][1];
        dp[i][1]=dp[i-1][0];
        dp[i][2]=dp[i-1][2]*10+dp[i-1][1];
    }
}
long long cal(long long n)
{
    memset(bit,0,sizeof bit);
    int len=0;
    while(n)
    {
        bit[++len]=n%10;
        n/=10;
    }
    long long ans=0;
    bool has=false;//n本身是否含49
    for(int i=len;i>=1;i--)//倒序计算  使得bit 变正序输出
    {
        ans+=dp[i-1][2]*bit[i];
        if(!has)
        {
            if(bit[i]>4)
                ans+=dp[i-1][1];
        }
        else ans+=dp[i-1][0]*bit[i];//一旦找到49 随便选
        if(bit[i+1]==4&&bit[i]==9)
            has=true;
    }
    if(has)
            ans++;
    return ans;
}
//以491为例，先求出所有比400小的数中有多少符合题意的，然后4这一位确定以后，再求所有比490小，再求出所有比491小  
//i=3 求出数 049 149 249 349  
//i=2 求出数 449  
//i=1 求出数 490  
//自身包含49 所以求出数491  
```
```
dp[i][0][j]表示第i位是j且恰好在上限的数有多少种
dp[i][1][j]表示第i位是j且小于上限的数有多少种
```
## 轮廓线DP
n* m 棋盘放1* 2棋子，问总共有多少种方法放满棋盘

n* m 的矩阵 1行有2^m 种 状态 每个状态用一个m位 01字符串表示后转化为10进制数
```
int n,m,cur;
const int maxn=11;
long long d[2][1<<maxn];//d[i][j]表示当前阶段为一点,状态为j时的种数，使用滚动数组
void update (int old,int news) //原来状态为old 转移状态为news   
{
    if(news&(1<<m))         d[cur][news^(1<<m)]+=d[1-cur][old];
    //news的从右向左(含第0位)第m位为1  将news的第m位变成0

}
int main()
{
    while(scanf("%d %d",&n,&m)==2)
    {
        if(n<m) swap(n,m);  //去m为较小的固定，降低时间复杂度
        memset(d,0,sizeof d);
        cur=0;
        d[0][(1<<m)-1]=1;
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
        {
            cur^=1;
            memset(d[cur],0,sizeof d[cur]);
            for(int k=0;k<(1<<m);k++){
                update(k,k<<1);//不放
            if(i&&!(k&(1<<(m-1))) update(k,(k<<1)^(1<<m)^1);//新状态 m位变0 第0位变1
            if(j&&!(k&1)) update(k,(k<<1)^3);//第0 和1 位变1
            }
        }
        printf("%lld\n",d[cur][(1<<m)-1]);//  I64d  wa
    }
    return 0;
}
```
## 概率DP

## DP优化 
具体看董浩爷爷的PPT
### 斜率优化
### 四边形不等式
### 矩阵快速幂+DP
### 插头DP
### AC自动机+DP
### 多维前缀和
### /32
### BIT

