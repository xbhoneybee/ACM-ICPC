# 不修改的区间问题
### 1 eg HDU4970

N=1e5 ,在1-N长度的区间上有N个子区间，每个子区间上+ or - 一个值，每次询问k-N的区间和

O N解法

设置一个Val[N+1];对每个子区间L，R ，v， 在Val[L]上+v，在Val[R+1]上-v 前到后跑一边前缀和，得到每个点的Val

从后往前跑一遍后缀和，得到k-N 的区间和

### 2 eg codeforces 835C

二维区间前缀和

求法 numofstar[y][x]=numofstar[y-1][x]+numofstar[y][x-1]-numofstar[y-1][x-1]+numofstar[y][x];

用法 给出左下右上坐标值
(numofstar[uy][rx]-numofstar[uy][lx-1]-numofstar[dy-1][rx]+numofstar[dy-1][lx-1]);

### 3 eg HDU6058
求1-n 所有区间的第k大之和，区间长度小于k的第k大为0

O NK解法

由于给出的区间是一个1-n置换
思路对于每一个i，要找到他前面k个大的，要找到后面k个大的。这样，i就是这些区间中第k大的（其实就是最小的）。
但是这种操作你需要枚举每一个数。复杂度为On。这样就不行，然后骚操作来了。
对于每一个数，记录比要查的数大的前一个位置，记录比要查的数大的数后一个位置，这样每次最多跳k次，这样复杂度就够了。
然后这就是链表，然后就是用数组来模拟链表。
pre表示上一个位置，nextp表示下一个位置。先算小的，算完后删掉，这样就不会影响到大的了。更新pre和nextp。
### SPOJ DQUERY D-query 
询问任意区间元素不同个数

解法一 离线+树状数组/线段树
对于一个询问区间[L,R],维护一个数组pos[i]表示最后i出现的位置，每次维护从1维护到R，更新每个a[i],最后出现的位置pos[a[i]]。并且将此位置加1，之前出现的位置-1，则区间[L,R]不同元素个数为树状数组求和 sum(R)-sum(L-1);

由于询问较多，采取离线处理，只用从左往右扫一遍即可。

解法二 主席树

## RMQ问题（待修改）
RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j<=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题

### ST算法（Sparse Table）
以求最大值为例，设d[i,j]表示[i,i+2^j-1]这个区间内的最大值，那么在询问到[a,b]区间的最大值时答案就是max(d[a,k], d[b-2^k+1,k])，其中k是满足2^k<=b-a+1(即长度)的最大的k,即k=[ln(b-a+1)/ln(2)]。                              
（查询）

d的求法可以用动态规划，d[i, j]=max(d[i, j-1],d[i+2^(j-1), j-1])。O(nlogn)*O(q) online。
首先是预处理，用一个DP解决。设a是要求区间最值的数列，f[i,j]表示从第i个数起连续2^j个数中的最大值。例如数列3 2 4 5 6 8 1 2 9 7 ,f[1,0]表示第1个数起，长度为2^0=1的最大值，其实就是3这个数。f[1,2]=5，f[1,3]=8，f[2,0]=2，f[2,1]=4……从这里可以看出f[i,0]其实就等于a[i]。这样，DP的状态、初值都已经有了，剩下的就是状态转移方程。我们把f[i,j]（j≥1）平均分成两段（因为j≥1时，f[i,j]一定是偶数个数字），从i到i+2^(j-1)-1为一段，i+2^(j-1)到i+2^j-1为一段（长度都为2^（j-1））。用上例说明，当i=1，j=3时就是3,2,4,5 和6,8,1,2这两段。f就是这两段的最大值中的最大值。于是我们得到了动规方程F[i,j]=max(F[i,j-1],F[i+2^(j-1),j-1])。

这样就计算了从l开始，长度为2^k的区间和从r-2^k+1开始长度为2^k的区间的最大值
任意的i至j之间的j-i+1个连续的值，一定可以分成两个2^n个数的两个区域（可以重合）。
比如说要求3到11之间的最值。

那么可以通过3到10之间的最值和4到11之间的最值求得3到11之间的最值，那么就可以和之前的f数组联系在一起了。
```
int f[1000005];
int maxsum[100005][20];
void RMQ(int num) //预处理->O(nlogn)
{
	for(int i=1;i<=num;i++)
        maxsum[i][0]=f[i];//f[i]为被操作数组，num为f长度
    int k=log(double(num+1))/log(2.0);
	for(int j = 1; j <= k; ++j)
		for(int i = 1;i+(1<<j)-1<=num;++i)
				maxsum[i][j]=max(maxsum[i][j-1], maxsum[i+(1<<(j-1))][j-1]);
}
int query(int l,int r)
{
    if(l>r) return 0;
    int k=floor(log2(r-l+1));
    return max(maxsum[l][k],maxsum[r-(1<<k)+1][k]);
}
```
这里我们需要注意的是循环的顺序，我们发现外层是j，内层所i，这是为什么呢？可以是i在外，j在内吗？

答案是不可以。因为我们需要理解这个状态转移方程的意义。

状态转移方程的含义是：先更新所有长度为F[i,0]即1个元素，然后通过2个1个元素的最值，获得所有长度为F[i,1]即2个元素的最值，然后再通过2个2个元素的最值，获得所有长度为F[i,2]即4个元素的最值，以此类推更新所有长度的最值。

而如果是i在外，j在内的话，我们更新的顺序就是F[1,0],F[1,1],F[1,2],F[1,3],表示更新从1开始1个元素，2个元素，4个元素，8个元素（A[0],A[1],....A[7]）的最值，这里F[1,3] = max(max(A[0],A[1],A[2],A[3]),max(A[4],A[5],A[6],A[7]))的值，但是我们根本没有计算max(A[0],A[1],A[2],A[3])和max(A[4],A[5],A[6],A[7])，所以这样的方法肯定是错误的。