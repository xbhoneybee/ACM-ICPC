# 分块
区间长度为N，易知分块时每块大小为根号N时，效率最高

分块的做法：
取x=(n)，以[1,x],[x+1,2x],[2x+1,3x]...分块
用pos数组维护端点i在第pos[i]块中。

写法
```
int belong[N]//属于那一块
int l[N],R[N]//每个数所在块左右边界
int block，blocksize；//块数，块大小
```
分块应用：

在线


# 莫队 
如果我们知道区间[L,R]，就能在O(1)求出[L−1,R],[L+1,R],[L,R−1],[L,R+1]的话，并且询问可以离线，那就可以用莫队算法了。

显然对于两次询问L,R和L′,R′，知道了L,R的答案,就可以暴力计算|L−L′|+|R−R′|次得出L′,R′的答案。

|L−L′|+|R−R′|。这个东西，数学上称之为曼哈顿距离

把每个询问看作是二维平面上的点，那么我们的最小总时间，就是这些点的最小曼哈顿距离生成树， 按照这个树的顺序做，复杂度变成了O(N√N)（为什么？不好意思，我不会证）

这样搞：

1)：排序，以左段点所在的块为第一关键字，以右端点为第二关键字

2)：从左往右处理询问（离线）

3)：不断调整l,r的位置并同时修改


 **PS 如果MLE 考虑每个块大小变为N^(2/3);**
## 支持修改的莫队
支持单点修改

分块大小S为n^(2/3)，那么我们就有n^(1/3)块。 
原本的莫队关键字只有两个，一个是左边界，一个是右边界。而带修改莫队要再加上一维：在第几个操作之后。 

我们按照这左边界所在块、右边界所在块以及第三关键字排序（上面说的那个）。 
统计答案时多维护一个指针记录修改操作执行到哪里，移动时直接修改即可，如果在区间内还要计算其对答案的影响。 

增加一个记录修改的结构体
```
struct Modify {
int pos,x,afmx;
}
```