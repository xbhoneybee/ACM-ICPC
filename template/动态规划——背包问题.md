## 背包问题
### 初始化
初始化的细节问题 我们看到的求最优解的背包问题题目中,事实上有两种不太相同的问法。有的题目要求“恰好装满背包”时的最优解,有的题目则并没有要求必须把背包装满。一种区别这两种问法的实现方法是在初始化的时候有所不同。如果是第一种问法,要求恰好装满背包,那么在初始化时除了f[0]为0其它f[1..V]均设为−∞,这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。如果并没有要求必须把背包装满,而是只希望价格尽量大,初始化时应该将f[0..V] 全部设为0。
为什么呢?可以这样理解:初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满,那么此时只有容量为0的背包可能被价值为0的nothing “恰好装满”,其它容量的背包均没有合法的解,属于未定义的状态,它们的值就都应该是−∞了。如果背包并非必须被装满,那么任何容量的背包都有一个合法解“什么都不装”,这个解的价值为0,所以初始时状态的值也就全部为0 了。
这个小技巧完全可以推广到其它类型的背包问题,后面也就不再对进行状态转移之前的初始化进行讲解。
### 01背包

dp[i][j]表示第i件物品放入容量为j的背包所得的最大价值

dp[i][j]=max{dp[i-1][j-v[i]]+c[i],dp[i-1][j]};

由于i  1->n 可转换为1维dp[j]=max{dp[j],dp[j-v[i]]+c[i]};
```
for（i=1;i<=n;i++）{
       for(j=V;j>=0;j--){//这里j 一定要从v->0,因为从2维到1维 若从1—>v dp[j-v[i]]表示dp[i][j-v[i]] 而不是dp[i-1][j-v[i]]
            if(j>=v[i])
              dp[j]=max{dp[j],dp[j-v[i]]+c[i]};
       }
}
dp[v]即为最大的价值
```
#### 常数优化 在V较大时效果好
```
for i ← 1 to N
    for v ← V to max (V−key, Ci )
```
key =sum cost(i -> n)

### 完全背包
以比较裸的思路思考完全背包，相当于对每件有不取，取一件，取2件...取V/c[i]件 复杂度O NV*Sum(V/c[i])

#### 简单优化
若两件物品 i 、 j 满足 c[i] < c[j] 且 w[i] > w[j] ，则将物品 j 去掉，不用考虑
#### 转为01背包求解
```
for（i=1;i<=n;i++）{
    for(j=v[i];j<=V;j++){//注意这里是从v[i]开始到Ｖ，因为可以放第i件物品多个，dp[j-v[i]]表示dp[i][j-v[i]]这里j>v[i]之后考虑的是放入第i件物品后的最优值，符合题意
          if(j>=v[i])
           dp[j]=max{dp[j],dp[j-v[i]]+c[i]};
    }
 }
//注意这列求出的dp[v]是最大的因为一直叠加
```
### 多重背包
第i种物品最多有n[i]件可用;

dp[i][j]=max{dp[i-1][v-k*v[i]]+k*c[i]|0<=k<=n[i]};(k表示第i种物品放入ｋ件);

#### 复杂度优化 
可以将第i中物品中有m件，转换为：
1 ， 2 ， 4 ，6 ，2* k 件，其中 2 *k <= m/2  很显然比上面这种用01背包来求解情况要少了很多logm个。
```
//未优化
for(i=1;i<=n;i++){
    for(j=v;j>=0;j--){
        for(k=1;k<=n[i];k++){
           if(j>=k*v[i])
            dp[i][j]=max(dp[i-1][v-k*v[i]]+k*c[i]，dp[i-1][j]))
           }
      }
}
```

### 混合3种背包
01背包与完全背包的混合考虑:一类物品只能取一次,另一类物品可以取无限次,那么只需在对每个物品应用转移方程时,根据物品的类别选用顺序或逆序的循环即可,复杂度是Θ(V N )。伪代码如下:
```
 for i ← 1 to N
 do if 第i件物品属于01背包
 then for v ← V to 0
 do f [v] = max{f [v], f [v − c[i]] + w[i]}
 else if 第i件物品属于完全背包
 then for v ← 0 to V
 do f [v] = maxf [v], f [v − c[i]] + w[i]
 ```
 ### 二维费用背包
 二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a[i]和b[i]。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w[i]；
费用加了一维，只需状态也加一维即可。设f[i][v][u]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。
状态转移方程就是：

**f[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}**


#### 物品总个数的限制 
有时, “二维费用”的条件是以这样一种隐含的方式给出的:最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用,每个物品的件数费用均为1,可以付出的最大件数费用为M。换句话说,设f[v][m]表示付出费用v、最多选m件时可得到的最大价值,则根据物品的类型(01、完全、多重)用不同的方法循环更新,最后在f[0..V][0..M]范围内寻找答案。

### 多维背包
类似二维费用，不过可以只消耗一种费用。解法开多维，多个for循环。
与for循环的几个费用的顺序无关 但注意要开临时变量不行的话 加一维
```
//x,y,z三种费用选一种花费
for(i = 1; i<=n; i++){
    for(x = k; x>=0; x--){
        for(y = v1; y>=0; y--){
            for(z = v2; z>=0; z--){
                int tem = 0;
                if(x-1>=0)
                tem = max(tem,dp[x-1][y][z]+s[i].w);
                if(y-s[i].a>=0)
                tem = max(tem,dp[x][y-s[i].a][z]+s[i].w);
                if(z-s[i].b>=0)
                tem = max(tem,dp[x][y][z-s[i].b]+s[i].w);
                dp[x][y][z] = max(dp[x][y][z],tem);
            }
        }
    }
}
```
### 分组背包
有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
这个问题变成了每组物品有若干种策略：**是选择本组的某一件，还是一件都不选。**

也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有：
    
    f[k][v]=max{f[k-1][v],f[k-1][v-c[i]]+w[i]|物品i属于组k}

使用一维数组的伪代码如下：
```
for 所有的组k
    for v=V..0
        for 所有的i属于组k
            f[v]=max{f[v],f[v-c[i]]+w[i]}
```
注意这里的三层循环的顺序

### 有依赖的背包问题
这种背包问题的物品间存在某种“依赖”的关系。也就是说， i 依赖于 j ，表示若
选物品 i ，则必须选物品 j 。

对于一维依赖关系

将不依赖于别
的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所
有的物品由若干主件和依赖于每个主件的一个附件集合组成。

对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，
我们可以对主件 i 的“附件集合”先进行一次 01 背包，得到费用依次为 0..V-c[i] 所有这些值时相应
的最大价值 f’[0..V-c[i]] 。那么这个主件及它的附件集合相当于 V-c[i]+1 个物品的物品组，其中费
用为 c[i]+k 的物品的价值为 f’[k]+w[i] 。也就是说原来指数级的策略中有很多策略都是冗余的，通
过一次 01 背包后，将主件 i 转化为 V-c[i]+1 个物品的物品组，就可以直接应用 分组背包的算法解决问题
了。

较一般的问题更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集
合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一
个物品（只有一个主件）且不出现循环依赖。
解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，
由于附件可能还有附件，就不能将每个附件都看作一个一般的 01 背包中的物品了。若这个附件
也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合
所对应的附件组中各个费用的附件所对应的价值。
事实上，这是一种**树形 DP** ，其特点是每个父节点都需要对它的各个儿子的属性进行一次 DP 以
求得自己的相关属性。这已经触及到了“泛化物品”的思想。你会发现这个“依赖
关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其
所有儿子的对应的泛化物品之和。

### 关于背包问题的问法
- 如果要求的是“总价值最小”“总件数最小”,只需简单的将上面的状态转移方程中的max改成min即可。
- **输出方案**  一般而言,背包问题是要求一个最优值,如果要求输 出这个最优值的方案,可以参照一般动态规划问题输出方案的方法:记录下每个状态的最优值是由状态转 移方程的哪一项推出来的,换句话说,记录下它是由 哪一个策略推出来的。便可根据这条策略找到上一 个状态,从上一个状态接着向前推即可。
 还是以01背包为例,方程为 

  f [i][v] = max{f [i−1][v], f [i−1][v−c[i]]+w[i]}。
  
  再用一个数组g[i][v],
设g[i][v]=0表示推出f[i][v]的值时是采用了方程的前一项(也即f [i][v] = f [i − 1][v] ), g[i][v]=1表示采用了方程的后一项。注意这两项分别表示了两种策略:未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写(设最终状态为f[N][V]):
  ```
  1 i ←  N

  2 v ←  V

  3 while i >  0

  4 do if g[i][v] =  0

  5 then print” 未选第 i 项物品 ”
  6 else if g[i][v] = 1)
  7 then print” 选了第 i 项物品 ”v ← v − c[i]
  另外，采用方程的前一项或后一项也可以在输出方案的过程中根据 f[i][v] 的值实时地求出
  来，也即不须纪录 g 数组，将上述代码中的 g[i][v]==0 改成 f[i][v] == f[i − 1][v] ， g[i][v] ==  1  改
  成 f[i][v] == f[i − 1][v − c[i]] + w[i] 也可。
  ```
- 输出字典序最小的最优方案 

  这里“字典序最小”的意思是 1..N 号物品的选择方案排列出来
  以后字典序最小。以输出 01 背包最小字典序的方案为例。
  一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定
  义要略改一些。我们注意到，如果存在一个选了物品 1 的最优方案，那么答案一定包含物品 1 ，原
  问题转化为一个背包容量为 v-c[1] ，物品为 2..N 的子问题。反之，如果答案不包含物品 1 ，则转化
  成背包容量仍为 V ，物品为 2..N 的子问题。不管答案怎样，子问题的物品都是以 i..N 而非前所述
  的 1..i 的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把
  物品逆序排列一下，**以下按物品已被逆序排列来叙述。**

  在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：
  从 N 到 1 输入时，如果 f[i][v] == f[i − 1][i − v] 及 f[i][v] == f[i − 1][f − c[i]] + w[i] 同时成立，应该按
  照后者（即选择了物品 i ）来输出方案。
- **求方案总数**

  对于一个给定了背包容量、物品费用、物品间相互关系(分组、依赖等)的背包问题,除了再给定每个物品的价值后求可得到的最大价值外,还可以得到装满背包或将背包装至某一指定容量的方案总数。对于这类改变问法的问题,一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是完全背包中的物品,转移方程即为
f [i][v] = sum{f [i − 1][v], f [i][v − c[i]]}
初始条件f[0][0]=1 
事实上,这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。
- 最优方案的总数

    这里的最优方案是指物品总价值最大的方案。以 01 背包为例。
结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求： f[i][v] 意义同
前述， g[i][v] 表示这个子问题的最优方案的总数，则在求 f[i][v] 的同时求 g[i][v] 的伪代码如下：
```
1 for i ← 1 to  N

2 do for v ← 0 to  V

3 do f[i][v] = max{f[i − 1][v],f[i − 1][v − c[i]] + w[i]}
4 g[i][v] =  0

5 if (f[i][v] = f[i − 1][v])
6 then g[i][v] ← g[i][v] + g[i − 1][v]
7 if f[i][v] = f[i − 1][v − c[i]] + w[i]
8 then g[i][v] ← g[i][v] + g[i − 1][v − c[i]]
```
- 求次优解、第K优解

    首先看 01 背包求最优解的状态转移方程：
    
    f[i][v] = max{f[i − 1][v],f[i− 1][v − c[i]] + w[i]} 。
    
    如
果要求第 K 优解，那么状态 f[i][v] 就应该是一个大小为 K 的数组 f[i][v][1..K] 。其中 f[i][v][k] 表示前 i 个
物品、背包大小为 v 时，第 k 优解的值。“ f[i][v] 是一个大小为 K 的数组”这一句，熟悉 C 语言的同学
可能比较好理解，或者也可以简单地理解为在原来的方程中加了一维。显然 f[i][v][1..K] 这 K 个数
是由大到小排列的，所以我们把它认为是一个有序队列。
然后原方程就可以解释为： f[i][v] 这个有序队列是由 f[i-1][v] 和 f[i-1][v-c[i]]+w[i] 这两个有序队列
合并得到的。有序队列 f[i-1][v] 即 f[i-1][v][1..K] ， f[i-1][v-c[i]]+w[i] 则理解为在 f[i-1][v-c[i]][1..K] 的每个数
上加上 w[i] 后得到的有序队列。合并这两个有序队列并将结果的前 K 项储存到 f[i][v][1..K] 中的复杂
度是 O(K) 。最后的答案是 f[N][V][K] 。总的复杂度是 Θ(V NK) 。